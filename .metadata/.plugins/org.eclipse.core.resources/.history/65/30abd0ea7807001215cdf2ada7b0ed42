package vis.clustering.quad;

import java.io.File;
import java.util.ArrayList;
import java.util.Random;

import org.apache.lucene.document.Document;

import vis.clustering.ClusterNode;
import vis.clustering.nn.ClusterFinder;
import vis.clustering.nn.ClusterObserver;
import vis.clustering.nn.Dumper;
import vis.db.VisualFeatures;
import vis.lucene.SearchResult;
import vis.lucene.Searcher;
import vis.metric.Metric;
import vis.view.quads.QuadInspector;

public class Quadrator {
	private static final int MAX_ITERATIONS = 1000000;
	private static final double SEMANTIC_ALPHA = 0.05;
	private int nodeCount, quadCount;
	private byte[][] finalDMatrix;
	private int[] nodeList;
	private int[] quadList;
	private double[] quadScore;
	
	private static final int CLUSTER = 4;
	
	private double[] n2mNodes;
	private double[] n2mMeanQuads;
	private double[] nodeVariances;
	
	private Random random = new Random();
	
	private double totalScore = 0;
	private double meanScore;
	
	VisualFeatures features = new VisualFeatures();
	Searcher searcher;
	
	
	public Quadrator(Searcher searcher){
		this.searcher = searcher;
	}
	
	public int[] getIds(){
		int[] finalIds = new int[nodeCount];
		for(int i=0; i<nodeCount; i++){
			finalIds[i] = nodeList[quadList[i]];
		}
		return finalIds;
	}	
	
	public double[] getQuadScore(){
		return quadScore;
	}
	
	public void setContext(int[] imageIds){
		nodeCount = imageIds.length;
		if(nodeCount % CLUSTER != 0){
			System.out.println("ERROR: Invalid node count.");
			return;
		}
		
		// data holders
		quadCount = nodeCount / CLUSTER;
		finalDMatrix = new byte[nodeCount][nodeCount];
		nodeList = new int[nodeCount];
		quadList = new int[nodeCount];
		quadScore = new double[nodeCount/CLUSTER];
		n2mNodes = new double[nodeCount];
		nodeVariances = new double[nodeCount];
		
		// store node ids in row		
		for(int g=0; g<nodeCount; g++){
			nodeList[g] = imageIds[g];
			quadList[g] = g;
		}		
		
		// calculate 		
		precalculation();
		
		// calculate score first time
		calculateScore();
	}
	
	public double getTotalScore(){
		return totalScore;
	}
	
	private void calculateScore(){	
		// reset total score
		totalScore = 0;
		
		// calculate the score of each quad
		double[] n2m = new double[CLUSTER];
		double[] vars = new double[CLUSTER];
		
		for(int q=0; q<quadCount; q++){
			// quad score
			quadScore[q] = getQuadScore(quadList, q, n2m, vars);
			
			// store n2m+variance for nodes
			for(int i=0; i<CLUSTER; i++){
				n2mNodes[q*CLUSTER+i] = n2m[i];
				nodeVariances[q*CLUSTER+i] = vars[i];
			}
			
			
			totalScore += quadScore[q];	// sum to total
		}
		
		meanScore = totalScore / quadCount;
	}
	
	private double getTotalScore(int[] row){		
		double ts = 0;
		for(int q=0; q<quadCount; q++){
			double qs = getQuadScore(row, q, null, null);			
			ts += qs;
		}
		return ts;		
	}
	
	private double _dist(int a, int b){
		double d = finalDMatrix[a][b]+128;
		
		return (d); //[0-255]
	}
	
	private double getQuadScore(int row[], int i, double[] meanN2M, double[] nodeVariance){
		// get distances from all nodes to each other
		//meanN2M = new double[CLUSTER];
		if(meanN2M == null){
			meanN2M = new double[CLUSTER];
		}
		
		if(nodeVariance == null){
			nodeVariance = new double[CLUSTER];
		}
		
		// mean n-to-m distances
		int o = i*CLUSTER;
		for(int n=0; n<CLUSTER; n++){
			int ida = row[o+n]; // image index in image list
							
			double td = 0;	// total distance
			for(int m=0; m<CLUSTER; m++){
				int idb = row[o+m];
				if(ida != idb)
					td += _dist(ida, idb);
			}			
			td /= CLUSTER-1;
			//System.out.println("->" + td);
			meanN2M[n] = td;
		}
		
		// mean mean n-to-m distances
		double mmeanN2M = 0;
		for(int n=0; n<CLUSTER; n++){
			mmeanN2M += meanN2M[n];
		}
		mmeanN2M /= CLUSTER;
		
		// variance
		double meanVariance = 0;
		for(int n=0; n<CLUSTER; n++){
			double kd = mmeanN2M-meanN2M[n];
			nodeVariance[n] = Math.sqrt(kd*kd);
			meanVariance += nodeVariance[n];
		}
		
		// mean variance		
		meanVariance /= CLUSTER;
		
		
		double finalScore = 0;
		
		if(mmeanN2M > 0){
			//finalScore = 1 / (mmeanN2M);
			finalScore = 1.0 / (1/meanVariance+0.9*mmeanN2M);			
		}else{
			finalScore = 1; // unlimited => max score
		}
		
		
		// final score
		return finalScore;
	}
	
	private int selectQuad(int unequal){
		int r = unequal;	
		while(r == unequal){
			// random selection
			//r = randomSelect();
			r = awareSelect();
		}
		
		return r;			
	}
	
	private int awareSelect(){
		// select lower scored quads with higher probability
		for(int j=0; j<quadCount; j++){
			int q = random.nextInt(quadCount);
			double s = quadScore[q];
			if(random.nextDouble() > s){
				return q;
			}
		}
		return random.nextInt(quadCount);
	}
	
	private int randomSelect(){
		return random.nextInt(quadCount);
	}
	
	
	
	public void magic(){
		int[] ng; 
		
		for(int i=0; i<MAX_ITERATIONS; i++){
			// randomly select two different quads
			int q1 = selectQuad(-1);
			int q2 = selectQuad(q1);	
			//System.out.println("sel " + q1 + "/" +q2);
			
			// get new generation
			ng = generate(quadList);
			
			// mutate
			mutateSwap(ng, q1, q2);
			
			// get score
			double s = getTotalScore(ng);			
			if(s > totalScore ){ // local minima?
				// store new list
				quadList = ng;
				
				// calculate score
				calculateScore();							
									
			}
			
			// repaint
			if(i % 10000 == 0){
				updateUI();
				System.out.println("#" + i + " :: " + totalScore + " | " );		
			}

		}
		
		updateUI();
	}
	
	private void updateUI(){
		if(QuadInspector.instance != null){
			QuadInspector.instance.repaint();
		}
	}
	
	/**
	 * mutate two quads
	 * @param row
	 * @param q1
	 * @param q2
	 */
	private void mutateSwap(int[] row, int q1, int q2){
		// select one node in each quad
		int n1 = q1*CLUSTER + random.nextInt(CLUSTER);
		int n2 = q2*CLUSTER + random.nextInt(CLUSTER);
		swapNodes(row, n1, n2);
	}
	
	private int vselect(int qi){
		double vmin = 0;
		
		if(random.nextDouble() > 0.7){
			return qi*CLUSTER+random.nextInt(CLUSTER);
		}
		
		int bc = -1;
		for(int c=0; c<CLUSTER; c++){
			double v = nodeVariances[qi*CLUSTER+c]/30; // bad
			if(v > vmin){
				bc = c;
				vmin = v;
			}
			//System.out.println(v);
			/*if(random.nextDouble() < v){
				return qi*CLUSTER+c;
			}*/
		}
		
		if(bc != -1){
			return qi*CLUSTER+bc;
		}
		
		return qi*CLUSTER+random.nextInt(CLUSTER);
	}
	
	private void mutateSwap2(int[] row, int q1, int q2){
		// select one node in each quad
		int n1 = vselect(q1);
		int n2 = vselect(q2);
		swapNodes(row, n1, n2);
	}
	
	private int[] generate(int[] seed){
		int[] ng = new int[seed.length];
		for(int g=0; g<ng.length; g++){ng[g] = seed[g];}
		return ng;	
	}
	
	
	
	private void swapNodes(int[] list, int a, int b){
		int buf = list[a];
		list[a] = list[b];
		list[b] = buf;
	}
	
	/**
	 * calculate distance matrix
	 */
	private void precalculation(){		
		// calculate max visual distance
		double maxDV = 0, d;
		for(int m=0; m<nodeCount; m++){
			for(int n=m; n<nodeCount; n++){
				d = getVisualDistance(m, n);
				if(d > maxDV) {
					maxDV = d;
				}
			}
		}
		
		
		
		// calculate final distance matrix	
		double norm = 1.0/maxDV;
		for(int m=0; m<nodeCount; m++){
			for(int n=m; n<nodeCount; n++){
				double cd = 1-Metric.cosim(getTags(n), getTags(m));
				// calculate final distance (add semantic)
				d = ((1-SEMANTIC_ALPHA)*norm * getVisualDistance(m, n)) + SEMANTIC_ALPHA*cd;	// thats bad, as we did this call above ...
				// TODO: add semantic distance (normalized as well)
				finalDMatrix[n][m] = finalDMatrix[m][n] = ((byte)(d*255-128));	
			}
		}	
	}
	
	private String getTags(int ni){
		String id = "" + nodeList[ni];
		Document d = searcher.get(id);
		return d.get("tags");
		
	}
	
	/**
	 * get direct visual distance
	 * @param a
	 * @param b
	 * @return
	 */
	private double getVisualDistance(int a, int b){
		int ia = nodeList[a]; // get ids
		int ib = nodeList[b];
		int[] f1 = features.getFeature(ia);
		int[] f2 = features.getFeature(ib);
		if(f1 != null && f2 != null){
			return Metric.distance(f1, f2);
		}
		
		return Double.MAX_VALUE;
	}
	
	/**
	 * dump a row
	 * @param row
	 */
	public void dumpRow(int row[]){
		for(int r=0; r<row.length; r++){
			System.out.print(row[r]);
			System.out.print(" - ");
		}
		System.out.println("");
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Searcher s = new Searcher(new File("index"));
		final ArrayList<SearchResult> results= new ArrayList<SearchResult>();
		
		/*s.search("isolated", 1200, new SearchCallback() {
			
			@Override
			public boolean onResult(SearchResult searchResult) {
				System.out.println(searchResult);
				results.add(searchResult);
				return true;
			}
		})*/;
				
		// use cluster finder to add images
		ClusterFinder finder = new ClusterFinder(s, 1.5);	
		ClusterObserver observer = new ClusterObserver(finder);
		observer.start();				
		finder.seed("gay");	
		for(ClusterNode n : finder.getResults()){
			results.add(n.getResult());			
		}
		
		
		
		int numi = results.size() - (results.size() % CLUSTER);
		
		
		// read ids from results
		int[] ids = new int[numi];
		int o = 0;
		for(SearchResult sr : results){
			
			ids[o++] = Integer.parseInt(sr.getId());
			if(o>numi-1){
				break;
			}
		}
		
		
		// 
		Quadrator q = new Quadrator(s);
		q.setContext(ids);
		
		QuadInspector qi = new QuadInspector(q);
		
		
		
		
		// perform
		q.magic();
		
		qi.repaint();
		
		Dumper.dumpRow(q, s);
		
		
		s.close();			
	}

}
