package vis.clustering.quad;

import java.util.Random;

import org.apache.lucene.document.Document;

import vis.db.VisualFeatures;
import vis.lucene.Searcher;
import vis.metric.Metric;
import vis.view.quads.QuadInspector;

/**
 * quadrator quad matcher
 * finds a quadruple of images in a set of images
 * using evolutionary strategy
 * 
 * @author timo
 *
 */
public class Quadrator {
	/* config */
	private static final int MAX_ITERATIONS = 50000000;
	
	/* distance matrix */
	private byte[][] finalDMatrix;
	
	/* node and quad holder */
	private int nodeCount, quadCount;
	private int[] nodeList;
	private int[] quadList;
	
	/* quad score */
	private double[] quadScore;
	
	public static final int CLUSTER = 4;
	private static final double LEARN_RATE = 0.9;
	
	private Random random = new Random();
	
	private double totalScore = 0;
	private double meanScore;	
	private VisualFeatures features = new VisualFeatures();
	private Searcher searcher;
	
	private double learnRate = 0.9;
	
	/**
	 * create quadrator
	 * @param searcher
	 */
	public Quadrator(Searcher searcher){
		this.searcher = searcher;
	}
	
	public int[] getIds(){
		int[] finalIds = new int[nodeCount];
		for(int i=0; i<nodeCount; i++){
			finalIds[i] = nodeList[quadList[i]];
		}
		return finalIds;
	}	
	
	/**
	 * retrieve quads score normalized
	 * @return
	 */
	public double[] getQuadScore(){
		return quadScore;
	}
	
	public void match(int[] imageIds){
		// init
		learnRate = LEARN_RATE;
		nodeCount = imageIds.length;
		if(nodeCount % CLUSTER != 0 ){
			System.out.println("ERROR: Invalid node count. = " + nodeCount);
			return;
		}
		
		// data holders
		quadCount = nodeCount / CLUSTER;
		finalDMatrix = new byte[nodeCount][nodeCount];
		nodeList = new int[nodeCount];
		quadList = new int[nodeCount];
		quadScore = new double[nodeCount/CLUSTER];
		
		// store node ids in row		
		for(int g=0; g<nodeCount; g++){
			nodeList[g] = imageIds[g];
			quadList[g] = g;
		}		
		
		// calculate 		
		precalculation();
		
		// calculate score first time
		calculateScore();
		
		if(quadCount < 2){
			System.out.println("Only on quad ...");
		}else{
			this.match();	
		}
		
		
	}
	
	public double getTotalScore(){
		return totalScore;
	}
	
	/**
	 * do a full score calculation
	 */
	private void calculateScore(){	
		totalScore = 0;		
		for(int q=0; q<quadCount; q++){
			quadScore[q] = getQuadScore(quadList, q);			
			totalScore += quadScore[q];	// sum to total
		}		
		meanScore = totalScore / quadCount;
	}	
	
	/**
	 * retrieve double encoded score
	 * TODO: maybe this is also an point of bottleneck reduction
	 * @param a
	 * @param b
	 * @return
	 */
	private double _dist(int a, int b){
		double d = ((int)(finalDMatrix[a][b])+128)/255.0;
		
		return (d); //[0-255]
	}
	
	private double getQuadScore(int row[], int i){
		// get distances from all nodes to each other
		double[] meanN2M = new double[CLUSTER];
		
		// mean n-to-m distances
		int o = i*CLUSTER;
		for(int n=0; n<CLUSTER; n++){
			int ida = row[o+n]; // image index in image list
							
			double td = 0;	// total distance
			for(int m=0; m<CLUSTER; m++){
				int idb = row[o+m];
				if(ida != idb)
					td += _dist(ida, idb);
			}	
			
			td /= CLUSTER-1;
			//System.out.println("td=" + td);
			meanN2M[n] = td;
		}
		
		// mean mean n-to-m distances
		double mmeanN2M = 0;
		for(int n=0; n<CLUSTER; n++){
			mmeanN2M += meanN2M[n];
		}
		//System.out.println(mmeanN2M);
		mmeanN2M /= CLUSTER;
		
		return 1.0-mmeanN2M;
	}
	
	private int selectQuad(int unequal){
		int r = unequal;	
		while(r == unequal){ r = random.nextInt(quadCount);	}		
		return r;			
	}	
		
	private void match(){
		int q1, q2;
		for(int i=0; i<MAX_ITERATIONS; i++){
			// randomly select two different quads
			q1 = selectQuad(-1);
			q2 = selectQuad(q1);
					
			// mutate
			mutateSwap(q1, q2);			
							
			// repaint
			if(i % 10 == 0){
				updateUI();
				System.out.println("#" + i + " :: " + totalScore + " | " + learnRate);		
			}
			
			learnRate*=0.9999995;
			if(learnRate < 0.0001){
				break;
			}

		}
		
		updateUI();
	}
	
	private void updateUI(){
		if(QuadInspector.instance != null){
			QuadInspector.instance.repaint();
		}
	}
	
	/**
	 * mutate two quads
	 * @param row
	 * @param q1
	 * @param q2
	 */
	private void mutateSwap(int q1, int q2){
		// select one node in each quad
		int n1 = q1*CLUSTER + random.nextInt(CLUSTER);
		int n2 = q2*CLUSTER + random.nextInt(CLUSTER);
		
		// swap nodes
		swapNodes(quadList, n1, n2);
		
		// calculate new score for mutated
		// quads
		double s1 = getQuadScore(quadList, q1);
		double s2 = getQuadScore(quadList, q2);
		if((s1+s2) > (quadScore[q1]+quadScore[q2]) || flip()){ // TODO: variance swap
			quadScore[q1] = s1;
			quadScore[q2] = s2;
		}else{
			// undo
			swapNodes(quadList, n1, n2);
		}				
	}
	
	private boolean flip(){		
		return Math.abs(random.nextGaussian()*learnRate) > (2);
	}
		
	
	
	
	
	/**
	 * swap two nodes
	 * @param list
	 * @param a
	 * @param b
	 */
	private void swapNodes(int[] list, int a, int b){
		int buf = list[a];
		list[a] = list[b];
		list[b] = buf;
	}
	
	/**
	 * calculate distance matrix
	 */
	private void precalculation(){		
		// calculate max visual distance
		// this seems bad, as we do the same 
		// call below to calculate final distance matrix
		// this is only needed for normalizing visual distance 
		// to make further calculations more easier. 
		// Since this only happens once (precalculation) its no that bad.
		// reason: we want to avoid to load a double distance matrix 
		// into ram -> sequential processing
		double maxDV = 0, d;
		for(int m=0; m<nodeCount; m++){
			for(int n=m; n<nodeCount; n++){
				d = getVisualDistance(m, n, 0);
				if(d > maxDV) {
					maxDV = d;
				}
			}
		}
					
		// calculate final distance matrix
		// with normalized and byte encoded values
		double norm = 1.0/maxDV;
		for(int m=0; m<nodeCount; m++){
			for(int n=m; n<nodeCount; n++){
				
				// calculate final distance (add semantic)
				d = norm * getVisualDistance(m, n, maxDV);
				
				// TODO: add semantic distance (normalized as well)
				finalDMatrix[n][m] = finalDMatrix[m][n] = ((byte)(d*255-128));
				//System.out.println("d=" + d + " // " + finalDMatrix[n][m]);
			}
		}	
	}
	
	/**
	 * get direct visual distance
	 * by node id (n-th node in list)
	 * @param a
	 * @param b
	 * @return
	 */
	private double getVisualDistance(int a, int b, double defaultValue){
		int ia = nodeList[a]; // get ids
		int ib = nodeList[b];
		byte[] f1 = features.getFeature(ia);
		byte[] f2 = features.getFeature(ib);
		if(f1 != null && f2 != null){
			return Metric.distance(f1, f2);
		}		
		return defaultValue; // might by bad, happens when feature not available in db 
	}
	
	/**
	 * dump a row
	 * @param row
	 */
	public void dumpRow(int row[]){
		for(int r=0; r<row.length; r++){
			System.out.print(row[r]);
			System.out.print(" - ");
		}
		System.out.println("");
	}

}
